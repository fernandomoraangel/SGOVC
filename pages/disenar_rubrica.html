<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diseñar Rúbrica - Sistema de Evaluación UdeA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link rel="stylesheet" href="../css/rubrics-styles.css">
    <!-- Alpine.js script moved to end of body -->
</head>

<body x-data="rubricSystem()">

    <div class="flex h-screen bg-gray-100">
        <aside class="w-64 bg-white shadow-md flex flex-col p-4">
            <div class="flex items-center justify-center mb-6 py-2">
                <span class="text-xl font-bold text-gray-700">Ude<span class="accent-pink">@</span> Digital</span>
            </div>

            <nav class="flex-1 space-y-2">
                <a href="disenar_rubrica.html"
                    class="w-full flex items-center space-x-4 p-4 rounded-md text-sm font-medium focus:outline-none focus:ring-2 focus:ring-pink-500 sidebar-active">
                    <!-- Active class applied -->
                    <i data-lucide="edit" class="w-5 h-5"></i>
                    <span>Diseñar Rúbrica</span>
                </a>
                <a href="evaluar_ovc.html"
                    class="w-full flex items-center space-x-3 p-2 rounded-md text-sm font-medium text-gray-600 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-pink-500">
                    <i data-lucide="file-check-2" class="w-5 h-5"></i>
                    <span>Evaluar OVC</span>
                </a>
                <a href="ver_promedios.html"
                    class="w-full flex items-center space-x-3 p-2 rounded-md text-sm font-medium text-gray-600 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-pink-500">
                    <i data-lucide="bar-chart-3" class="w-5 h-5"></i>
                    <span>Ver Promedios</span>
                </a>
                <a href="resumen_rubricas.html"
                    class="w-full flex items-center space-x-3 p-2 rounded-md text-sm font-medium text-gray-600 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-pink-500">
                    <i data-lucide="list" class="w-5 h-5"></i>
                    <span>Resumen Rúbricas</span>
                </a>
            </nav>

            <div class="mt-auto border-t pt-4">
                <p class="text-xs text-gray-500 text-center">© 2024 Universidad de Antioquia</p>
            </div>
        </aside>

        <main class="flex-1 flex flex-col overflow-hidden">


            </header>

            <div class="flex-1 overflow-x-hidden overflow-y-auto bg-gray-100 p-6">


                <!-- Message Display Area -->
                <div x-show="message.text" x-transition
                    :class="{ 'bg-green-100 border-green-400 text-green-700': message.type === 'success', 'bg-red-100 border-red-400 text-red-700': message.type === 'error', 'bg-blue-100 border-blue-400 text-blue-700': message.type === 'info' }"
                    class="border px-4 py-3 rounded relative mb-4" role="alert">
                    <span class="block sm:inline" x-text="message.text"></span>
                    <span @click="message.text = ''" class="absolute top-0 bottom-0 right-0 px-4 py-3 cursor-pointer">
                        <svg class="fill-current h-6 w-6" role="button" xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 20 20">
                            <title>Cerrar</title>
                            <path
                                d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z" />
                        </svg>
                    </span>
                </div>

                <!-- Rubric Designer Section -->
                <div> <!-- Removed x-show as this is the only content -->


                    <!-- AI Generation Section -->
                    <div class="p-4 border border-dashed border-pink-300 rounded-md bg-pink-50 mb-6">
                        <h3 class="text-lg font-medium text-gray-800 mb-2 flex items-center">
                            <i data-lucide="sparkles" class="w-5 h-5 mr-2 text-pink-600"></i> Generar con IA
                        </h3>
                        <p class="text-sm text-gray-600 mb-3">Describe el tema o la tarea para la cual necesitas la
                            rúbrica, y la IA generará una propuesta inicial.</p>
                        <div>
                            <label for="aiTopic" class="block text-sm font-medium text-gray-700">Tema/Tarea para la
                                Rúbrica</label>
                            <input type="text" id="aiTopic" x-model="aiRubricTopic"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-accent-pink focus:ring-accent-pink sm:text-sm"
                                placeholder="Ej: Ensayo argumentativo sobre cambio climático">
                        </div>
                        <div class="mt-3 text-right">
                            <button @click="generateRubricWithAi()"
                                :disabled="!aiRubricTopic.trim() || isGeneratingAiRubric"
                                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-accent-pink hover:bg-accent-pink-dark focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-accent-pink disabled:opacity-50 disabled:cursor-not-allowed">
                                <span x-show="!isGeneratingAiRubric">
                                    <i data-lucide="wand-2" class="w-4 h-4 mr-2"></i> Generar Rúbrica
                                </span>
                                <span x-show="isGeneratingAiRubric">
                                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white"
                                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                            stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor"
                                            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                        </path>
                                    </svg>
                                    Generando...
                                </span>
                            </button>
                        </div>
                    </div>
                    <!-- End AI Generation Section -->

                    <div class="space-y-4">
                        <div>
                            <label for="rubricTitle" class="block text-sm font-medium text-gray-700">Título de la
                                Rúbrica (Editable)</label>
                            <input type="text" id="rubricTitle" x-model="newRubric.title"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-accent-pink focus:ring-accent-pink sm:text-sm"
                                placeholder="Ej: Rúbrica para Presentación Oral">
                        </div>

                        <h3 class="text-lg font-medium text-gray-800 pt-4">Criterios de Desempeño</h3>
                        <div class="space-y-4">
                            <template x-for="(criterion, critIndex) in newRubric.criteria" :key="critIndex">
                                <div class="p-4 border border-gray-200 rounded-md bg-gray-50">
                                    <div class="flex justify-between items-center mb-2">
                                        <h4 class="text-md font-semibold text-gray-700"
                                            x-text="'Criterio ' + (critIndex + 1)"></h4>
                                        <button @click="removeCriterion(critIndex)"
                                            class="text-red-600 hover:text-red-800">
                                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                                        </button>
                                    </div>
                                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-3">
                                        <div class="md:col-span-2">
                                            <label :for="'critName' + critIndex"
                                                class="block text-sm font-medium text-gray-700">Nombre del
                                                Criterio</label>
                                            <input type="text" :id="'critName' + critIndex" x-model="criterion.name"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-accent-pink focus:ring-accent-pink sm:text-sm"
                                                placeholder="Ej: Claridad del Contenido">
                                        </div>
                                        <div>
                                            <label :for="'critWeight' + critIndex"
                                                class="block text-sm font-medium text-gray-700">Peso (%)</label>
                                            <input type="number" :id="'critWeight' + critIndex"
                                                x-model.number="criterion.weight" min="0" max="100"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-accent-pink focus:ring-accent-pink sm:text-sm"
                                                placeholder="Ej: 20">
                                        </div>
                                    </div>

                                    <h5 class="text-sm font-medium text-gray-600 mb-2">Niveles de Desempeño</h5>
                                    <div class="space-y-3">
                                        <template x-for="(level, levelIndex) in criterion.levels" :key="levelIndex">
                                            <div class="p-3 border border-gray-100 rounded bg-white shadow-sm">
                                                <div class="flex justify-between items-start mb-1">
                                                    <span class="text-sm font-semibold text-gray-600"
                                                        x-text="'Nivel ' + (levelIndex + 1)"></span>
                                                    <button @click="removeLevel(critIndex, levelIndex)"
                                                        class="text-red-500 hover:text-red-700">
                                                        <i data-lucide="x" class="w-3 h-3"></i>
                                                    </button>
                                                </div>
                                                <div class="grid grid-cols-1 md:grid-cols-5 gap-3">
                                                    <div class="md:col-span-2">
                                                        <label :for="'levelName' + critIndex + levelIndex"
                                                            class="block text-xs font-medium text-gray-500">Nombre</label>
                                                        <input type="text" :id="'levelName' + critIndex + levelIndex"
                                                            x-model="level.name"
                                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-accent-pink focus:ring-accent-pink sm:text-sm text-xs"
                                                            placeholder="Ej: Sobresaliente">
                                                    </div>
                                                    <div>
                                                        <label :for="'levelScore' + critIndex + levelIndex"
                                                            class="block text-xs font-medium text-gray-500">Puntaje</label>
                                                        <input type="number" :id="'levelScore' + critIndex + levelIndex"
                                                            x-model.number="level.score"
                                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-accent-pink focus:ring-accent-pink sm:text-sm text-xs"
                                                            placeholder="Ej: 5">
                                                    </div>
                                                    <div class="md:col-span-2">
                                                        <label :for="'levelDesc' + critIndex + levelIndex"
                                                            class="block text-xs font-medium text-gray-500">Descripción</label>
                                                        <textarea :id="'levelDesc' + critIndex + levelIndex"
                                                            x-model="level.description" rows="2"
                                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-accent-pink focus:ring-accent-pink sm:text-sm text-xs"
                                                            placeholder="Descripción del nivel..."></textarea>
                                                    </div>
                                                </div>
                                            </div>
                                        </template>
                                    </div>
                                    <button @click="addLevel(critIndex)"
                                        class="mt-3 inline-flex items-center px-3 py-1 border border-transparent text-xs font-medium rounded shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                                        <i data-lucide="plus" class="w-3 h-3 mr-1"></i> Añadir Nivel
                                    </button>
                                </div>
                            </template>
                        </div>

                        <div class="flex justify-between items-center mt-4">
                            <button @click="addCriterion()"
                                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
                                <i data-lucide="plus-circle" class="w-5 h-5 mr-2"></i> Añadir Criterio
                            </button>
                            <div class="text-right">
                                <p class="text-sm font-medium text-gray-600">Peso Total: <span x-text="totalWeight"
                                        :class="{ 'text-red-600': totalWeight !== 100, 'text-green-600': totalWeight === 100 }"></span>%
                                </p>
                                <p x-show="totalWeight !== 100" class="text-xs text-red-500">El peso total debe
                                    sumar 100%.</p>
                            </div>
                        </div>

                        <div class="mt-6 text-right space-x-3">
                            <button @click="downloadRubric" :disabled="!canSaveRubric"
                                class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed">
                                <i data-lucide="download" class="w-4 h-4 mr-2"></i> Descargar JSON
                            </button>
                            <button @click="saveRubric" :disabled="!canSaveRubric"
                                class="inline-flex items-center px-6 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-accent-pink hover:bg-accent-pink-dark focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-accent-pink disabled:opacity-50 disabled:cursor-not-allowed">
                                <i data-lucide="save" class="w-5 h-5 mr-2"></i> Guardar Rúbrica
                            </button>
                        </div>
                    </div>
                </div>
                <!-- End Rubric Designer Section -->


            </div>
            <footer class="bg-white border-t border-gray-200 p-3 text-center text-xs text-gray-500">
                Todos los derechos reservados 2024 :: Universidad de Antioquia :: Vicerrectoría de Docencia
            </footer>

        </main>
    </div>

    <!-- Inline script defining component and attaching listener -->
    <script>
        // IMPORTANT: Replace 'YOUR_GOOGLE_API_KEY' with your actual Google AI API key if using AI generation
        const GOOGLE_API_KEY = 'AIzaSyA5rWKqgBArqtg5aZiQiQFMRpZWcOsHwT0'; // Replace if needed
        const AI_MODEL_NAME = 'gemini-1.5-flash-latest';

        // Define the component logic
        function rubricSystemComponent() {
            return {
                // Keep existing data properties: currentTab, message, newRubric, etc.
                currentTab: 'designer', // Set default tab for this page
                message: { text: '', type: 'info', timer: null }, // type: 'success', 'error', 'info'
                newRubric: {
                    title: '',
                    criteria: []
                },
                savedRubrics: [], // Array to hold saved rubric objects
                evaluation: { // Data for the current evaluation being performed (kept for potential future use/consistency)
                    ovcTitle: '',
                    evaluatorName: '',
                    evaluatorId: '',
                    subject: '',
                    percentage: null,
                    rubric: null, // The selected rubric object
                    scores: [], // Array to hold scores for each criterion [score1, score2, ...]
                    feedback: '',
                    calculatedGrade: null,
                    timestamp: null
                },
                selectedRubricTitle: '', // Title of the rubric selected in the evaluator tab
                allEvaluations: {}, // Object to hold all submitted evaluations { ovcTitle: [eval1, eval2], ... }
                selectedOvcForAverage: '', // OVC title selected in the viewer tab
                averageScore: null,
                evaluationCount: 0,
                individualEvaluations: [],
                showIndividualEvaluations: false,
                rubricToDeleteIndex: null, // Index of rubric marked for deletion
                aiRubricTopic: '', // Input for AI generation
                isGeneratingAiRubric: false, // Loading state for AI generation


                // --- Computed property for dynamic page title ---
                get pageTitle() {
                    // Simplified for this page, but kept for consistency if copied elsewhere
                    switch (this.currentTab) {
                        case 'designer': return 'Diseñador de Rúbricas';
                        case 'evaluator': return 'Evaluador de OVC';
                        case 'viewer': return 'Visor de Promedios';
                        case 'summary': return 'Resumen de Rúbricas';
                        default: return 'Sistema de Evaluación';
                    }
                },

                // Initialization
                init() {
                    console.log('Initializing Rubric System on Designer Page...');
                    this.loadSavedRubrics(); // Load rubrics first
                    this.loadSavedEvaluations(); // Load evaluations too, needed for viewer/summary logic if kept

                    let loadedForEdit = false;
                    try {
                        const urlParams = new URLSearchParams(window.location.search);
                        const editIndexStr = urlParams.get('editIndex');
                        if (editIndexStr !== null) {
                            const editIndex = parseInt(editIndexStr, 10);
                            if (!isNaN(editIndex) && editIndex >= 0 && editIndex < this.savedRubrics.length) {
                                console.log(`Found editIndex in URL: ${editIndex}. Loading rubric for editing.`);
                                // Use $nextTick or simply call directly if loadSavedRubrics is synchronous
                                this.editRubric(editIndex); // Call the existing editRubric function
                                loadedForEdit = true;
                            } else {
                                console.warn(`Invalid editIndex found in URL: ${editIndexStr}`);
                                this.showMessage(`Índice de rúbrica inválido (${editIndexStr}) proporcionado para editar.`, 'error');
                            }
                        }
                    } catch (e) {
                        console.error("Error processing editIndex from URL:", e);
                    }

                    // Add a default criterion and level only if NOT loading for edit
                    if (!loadedForEdit && this.newRubric.criteria.length === 0) {
                        this.addCriterion();
                    }

                    // Icon initialization moved to alpine:init listener
                },

                // --- Rubric Designer Methods ---
                addCriterion() {
                    this.newRubric.criteria.push({
                        name: '',
                        weight: null,
                        levels: [{ name: '', score: null, description: '' }] // Start with one level
                    });
                },
                removeCriterion(index) {
                    this.newRubric.criteria.splice(index, 1);
                },
                addLevel(criterionIndex) {
                    this.newRubric.criteria[criterionIndex].levels.push({ name: '', score: null, description: '' });
                },
                removeLevel(criterionIndex, levelIndex) {
                    this.newRubric.criteria[criterionIndex].levels.splice(levelIndex, 1);
                },
                get totalWeight() {
                    // Explicitly parse weights as floats and round the final sum
                    const sum = this.newRubric.criteria.reduce((sum, crit) => {
                        const weight = parseFloat(crit.weight);
                        return sum + (isNaN(weight) ? 0 : weight); // Add valid weight, otherwise 0
                    }, 0);
                    // Round to 2 decimal places to handle potential floating point inaccuracies
                    return Math.round(sum * 100) / 100;
                },
                get canSaveRubric() {
                    if (!this.newRubric.title.trim()) return false;
                    if (this.newRubric.criteria.length === 0) return false;
                    // Use tolerance for floating point comparison
                    if (Math.abs(this.totalWeight - 100) > 0.001) {
                        if (this.newRubric.criteria.length > 0 && this.newRubric.criteria.some(c => c.weight !== null && c.weight !== '')) {
                            // Avoid constant messages during typing
                        }
                        return false;
                    }
                    let levelScoreError = false;
                    let levelNameError = false;
                    let critNameError = false;

                    for (const crit of this.newRubric.criteria) {
                        if (!crit.name.trim() || crit.weight === null || crit.weight <= 0) return false;
                        if (crit.levels.length === 0) return false;
                        for (const level of crit.levels) {
                            if (!level.name.trim() || level.score === null) return false; // Description is optional
                        }
                        const scores = crit.levels.map(l => l.score).filter(s => s !== null);
                        if (new Set(scores).size !== scores.length) {
                            levelScoreError = true;
                        }
                        const names = crit.levels.map(l => l.name.trim().toLowerCase()).filter(n => n !== '');
                        if (new Set(names).size !== names.length) {
                            levelNameError = true;
                        }
                    }
                    const critNames = this.newRubric.criteria.map(c => c.name.trim().toLowerCase()).filter(n => n !== '');
                    if (new Set(critNames).size !== critNames.length) {
                        critNameError = true;
                    }

                    // Show specific error messages only once if validation fails and button is attempted
                    // Moved message logic to saveRubric() for better UX
                    return !levelScoreError && !levelNameError && !critNameError;
                },
                saveRubric() {
                    // Re-check validation and show specific messages on save attempt
                    let errorMsg = '';
                    if (!this.newRubric.title.trim()) errorMsg = 'El título de la rúbrica no puede estar vacío.';
                    else if (this.newRubric.criteria.length === 0) errorMsg = 'Debe añadir al menos un criterio.';
                    // Use tolerance for floating point comparison (totalWeight is now rounded)
                    else if (Math.abs(this.totalWeight - 100) > 0.001) errorMsg = 'La suma de los pesos de los criterios debe ser 100%.';
                    else {
                        let levelScoreError = false;
                        let levelNameError = false;
                        let critNameError = false;
                        let fieldMissingError = false;
                        for (const crit of this.newRubric.criteria) {
                            if (!crit.name.trim() || crit.weight === null || crit.weight <= 0) fieldMissingError = true;
                            if (crit.levels.length === 0) fieldMissingError = true;
                            for (const level of crit.levels) {
                                if (!level.name.trim() || level.score === null) fieldMissingError = true;
                            }
                            const scores = crit.levels.map(l => l.score).filter(s => s !== null);
                            if (new Set(scores).size !== scores.length) levelScoreError = true;
                            const names = crit.levels.map(l => l.name.trim().toLowerCase()).filter(n => n !== '');
                            if (new Set(names).size !== names.length) levelNameError = true;
                        }
                        const critNames = this.newRubric.criteria.map(c => c.name.trim().toLowerCase()).filter(n => n !== '');
                        if (new Set(critNames).size !== critNames.length) critNameError = true;

                        if (fieldMissingError) errorMsg = 'Por favor, complete todos los nombres y puntajes/pesos requeridos.';
                        else if (levelScoreError) errorMsg = 'Los puntajes de los niveles dentro de un mismo criterio deben ser únicos.';
                        else if (levelNameError) errorMsg = 'Los nombres de los niveles dentro de un mismo criterio deben ser únicos.';
                        else if (critNameError) errorMsg = 'Los nombres de los criterios deben ser únicos.';
                    }

                    if (errorMsg) {
                        this.showMessage(errorMsg, 'error');
                        return;
                    }

                    // Proceed with saving if validation passes
                    const rubricToSave = JSON.parse(JSON.stringify(this.newRubric));
                    rubricToSave.criteria.forEach(crit => {
                        crit.levels.sort((a, b) => a.score - b.score);
                    });
                    const existingIndex = this.savedRubrics.findIndex(r => r.title === rubricToSave.title);
                    if (existingIndex !== -1) {
                        this.savedRubrics[existingIndex] = rubricToSave;
                        this.showMessage(`Rúbrica '${rubricToSave.title}' actualizada exitosamente.`, 'success');
                    } else {
                        this.savedRubrics.push(rubricToSave);
                        this.showMessage(`Rúbrica '${rubricToSave.title}' guardada exitosamente.`, 'success');
                    }
                    localStorage.setItem('savedRubrics', JSON.stringify(this.savedRubrics));
                    this.resetRubricForm(); // Optionally reset form after saving
                    // Maybe navigate to summary page? For now, stay here.
                    // window.location.href = 'resumen_rubricas.html'; // Uncomment to navigate
                },
                downloadRubric() {
                    if (!this.canSaveRubric) { // Use the getter for quick check, specific errors shown on attempt
                        this.showMessage('Complete la rúbrica correctamente antes de descargarla. Verifique pesos, nombres y puntajes.', 'error');
                        return;
                    }
                    const rubricToDownload = JSON.parse(JSON.stringify(this.newRubric));
                    rubricToDownload.criteria.forEach(crit => {
                        crit.levels.sort((a, b) => a.score - b.score);
                    });
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(rubricToDownload, null, 2));
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    const fileName = rubricToDownload.title.replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.json';
                    downloadAnchorNode.setAttribute("download", fileName);
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                    this.showMessage('Archivo JSON de la rúbrica generado para descarga.', 'info');
                },
                resetRubricForm() {
                    this.newRubric = { title: '', criteria: [] };
                    this.aiRubricTopic = ''; // Also reset AI topic
                    this.addCriterion(); // Add the initial empty criterion back
                },
                loadSavedRubrics() {
                    const storedRubrics = localStorage.getItem('savedRubrics');
                    if (storedRubrics) {
                        try {
                            this.savedRubrics = JSON.parse(storedRubrics);
                        } catch (e) {
                            console.error("Error loading saved rubrics:", e);
                            localStorage.removeItem('savedRubrics'); // Clear corrupted data
                            this.savedRubrics = [];
                            this.showMessage('Error al cargar las rúbricas guardadas. Se han restablecido.', 'error');
                        }
                    }
                },
                // --- Methods needed for loading/saving, potentially used by other parts if code is reused ---
                loadSavedEvaluations() {
                    const storedEvaluations = localStorage.getItem('allEvaluations');
                    if (storedEvaluations) {
                        try {
                            this.allEvaluations = JSON.parse(storedEvaluations);
                        } catch (e) {
                            console.error("Error loading saved evaluations:", e);
                            localStorage.removeItem('allEvaluations');
                            this.allEvaluations = {};
                            this.showMessage('Error al cargar las evaluaciones guardadas.', 'error');
                        }
                    }
                },
                // --- Edit/Delete methods (might be called from summary page if using same JS) ---
                editRubric(index) {
                    // This function would typically be called from the summary view.
                    // If called here, it loads the selected rubric into the designer.
                    const rubricToEdit = this.savedRubrics[index];
                    if (rubricToEdit) {
                        this.newRubric = JSON.parse(JSON.stringify(rubricToEdit));
                        this.currentTab = 'designer'; // Ensure we are on the designer tab
                        this.showMessage(`Editando la rúbrica: ${rubricToEdit.title}`, 'info');
                        window.scrollTo(0, 0); // Scroll to top
                    } else {
                        this.showMessage('Error: No se pudo encontrar la rúbrica para editar.', 'error');
                    }
                },
                confirmDeleteRubric(index) {
                    // This function would typically be called from the summary view.
                    const rubricTitle = this.savedRubrics[index]?.title;
                    if (rubricTitle && confirm(`¿Está seguro de que desea eliminar la rúbrica "${rubricTitle}"? Esta acción no se puede deshacer.`)) {
                        this.deleteRubric(index);
                    }
                },
                deleteRubric(index) {
                    // This function would typically be called from the summary view.
                    const deletedTitle = this.savedRubrics[index]?.title;
                    this.savedRubrics.splice(index, 1);
                    localStorage.setItem('savedRubrics', JSON.stringify(this.savedRubrics));
                    this.showMessage(`Rúbrica "${deletedTitle}" eliminada exitosamente.`, 'success');
                    // If the currently edited rubric was the one deleted, reset the form
                    if (this.newRubric.title === deletedTitle) {
                        this.resetRubricForm();
                    }
                },

                // --- Utility Methods ---
                showMessage(text, type = 'info', duration = 5000) {
                    if (this.message.timer) {
                        clearTimeout(this.message.timer);
                    }
                    this.message.text = text;
                    this.message.type = type;
                    this.message.timer = setTimeout(() => {
                        this.message.text = '';
                        this.message.timer = null;
                    }, duration);
                },

                // --- AI Rubric Generation Method ---
                async generateRubricWithAi() {
                    if (!this.aiRubricTopic.trim()) {
                        this.showMessage('Por favor, ingrese el tema para la rúbrica.', 'error');
                        return;
                    }
                    if (!GOOGLE_API_KEY || GOOGLE_API_KEY === 'YOUR_GOOGLE_API_KEY') {
                        this.showMessage('Error: La clave API de Google AI no está configurada. Reemplace YOUR_GOOGLE_API_KEY en el script.', 'error', 10000);
                        return;
                    }

                    this.isGeneratingAiRubric = true;
                    this.showMessage('Generando rúbrica con IA...', 'info', 15000);

                    const prompt = `
                       Por favor, crea una rúbrica de evaluación detallada en formato JSON para el siguiente tema o tarea: "${this.aiRubricTopic}".
                       El JSON debe tener la siguiente estructura:
                       {
                         "title": "Un título descriptivo para la rúbrica relacionado con '${this.aiRubricTopic}'",
                         "criteria": [
                           {
                             "name": "Nombre del criterio (ej: Claridad)",
                             "weight": Un número entero representando el porcentaje de peso (distribuye los pesos para que sumen 100 entre todos los criterios),
                             "levels": [
                               {
                                 "name": "Nombre del nivel (ej: Sobresaliente)",
                                 "score": Un número entero para el puntaje del nivel (ej: 5),
                                 "description": "Descripción clara y concisa de lo esperado en este nivel para este criterio."
                               },
                               // ... otros niveles (generalmente 3-5 niveles por criterio, ordenados de menor a mayor puntaje)
                             ]
                           },
                           // ... otros criterios (generalmente 3-6 criterios en total)
                         ]
                       }

                       Asegúrate de que:
                       - El JSON sea válido.
                       - Los pesos ("weight") de los criterios sumen exactamente 100.
                       - Haya entre 3 y 6 criterios.
                       - Cada criterio tenga entre 3 y 5 niveles de desempeño.
                       - Los niveles dentro de cada criterio estén ordenados por puntaje ("score") de menor a mayor.
                       - Las descripciones sean útiles y específicas para la evaluación.
                       - El título sea relevante para "${this.aiRubricTopic}".
                       - Solo responde con el objeto JSON, sin texto adicional antes o después.
                   `;

                    try {
                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${AI_MODEL_NAME}:generateContent?key=${GOOGLE_API_KEY}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    responseMimeType: "application/json",
                                }
                            }),
                        });

                        if (!response.ok) {
                            const errorBody = await response.json();
                            console.error('Google AI API Error:', errorBody);
                            throw new Error(`Error de la API de IA: ${errorBody.error?.message || response.statusText}`);
                        }

                        const data = await response.json();

                        if (!data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                            console.error('Invalid AI response structure:', data);
                            throw new Error('La respuesta de la IA no tuvo el formato esperado.');
                        }

                        let jsonString = data.candidates[0].content.parts[0].text;
                        const jsonMatch = jsonString.match(/```json\s*([\s\S]*?)\s*```/);
                        if (jsonMatch && jsonMatch[1]) {
                            jsonString = jsonMatch[1];
                        }

                        const generatedRubric = JSON.parse(jsonString);

                        // Basic validation
                        if (!generatedRubric || typeof generatedRubric !== 'object' || !generatedRubric.title || !Array.isArray(generatedRubric.criteria)) {
                            console.error('Invalid generated rubric structure:', generatedRubric);
                            throw new Error('La estructura de la rúbrica generada por la IA no es válida.');
                        }
                        // Deeper validation
                        let validationError = null;
                        let calculatedWeight = 0;
                        if (generatedRubric.criteria.length === 0) validationError = "La IA no generó criterios.";
                        generatedRubric.criteria.forEach(crit => {
                            if (!crit.name || typeof crit.weight !== 'number' || !Array.isArray(crit.levels) || crit.levels.length === 0) {
                                validationError = "Algunos criterios generados no tienen nombre, peso o niveles válidos.";
                            }
                            calculatedWeight += (crit.weight || 0);
                            crit.levels.forEach(level => {
                                if (!level.name || typeof level.score !== 'number' || !level.description) {
                                    validationError = "Algunos niveles generados no tienen nombre, puntaje o descripción válidos.";
                                }
                            });
                            crit.levels.sort((a, b) => a.score - b.score);
                        });

                        if (Math.abs(calculatedWeight - 100) > 1) {
                            validationError = `Los pesos generados (${calculatedWeight}%) no suman 100%. Puedes ajustarlos manualmente.`;
                        }

                        if (validationError) {
                            this.showMessage(`Advertencia: ${validationError}`, 'error', 8000);
                        } else {
                            this.showMessage('Rúbrica generada por IA exitosamente. Revísala y ajústala si es necesario.', 'success');
                        }

                        this.newRubric = generatedRubric;
                        if (this.newRubric.criteria.length === 0) {
                            this.addCriterion();
                        } else {
                            this.newRubric.criteria.forEach((crit, index) => {
                                if (crit.levels.length === 0) {
                                    this.addLevel(index);
                                }
                            });
                        }


                    } catch (error) {
                        console.error('Error generating rubric with AI:', error);
                        this.showMessage(`Error al generar la rúbrica: ${error.message}`, 'error', 10000);
                    } finally {
                        this.isGeneratingAiRubric = false;
                        this.$nextTick(() => lucide.createIcons());
                    }
                }
                // --- End AI Method ---

            } // End of return object for Alpine data
        } // End of rubricSystemComponent function

        // Register the component with Alpine BEFORE it initializes x-data
        document.addEventListener('alpine:init', () => {
            Alpine.data('rubricSystem', rubricSystemComponent);
            console.log('Alpine component "rubricSystem" registered.');
            // Initialize icons right after registration
            try {
                console.log('Attempting Lucide icon creation within alpine:init');
                lucide.createIcons();
            } catch (e) {
                console.error('Error creating Lucide icons within alpine:init:', e);
            }
        });

        // Optional: Log if alpine:initialized fires
        document.addEventListener('alpine:initialized', () => {
            console.log('Alpine initialized event fired.');
        });

    </script>
    <!-- Alpine.js library script - MUST come AFTER the alpine:init listener is attached -->
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script>
        // Hide sidebar if loaded inside an iframe (e.g., within index.html)
        if (window.self !== window.top) {
            const sidebar = document.querySelector('aside.w-64'); // Target the specific sidebar
            if (sidebar) {
                sidebar.classList.add('hidden');
                // Optional: Adjust main content margin/padding if needed when sidebar is hidden
                const mainContent = document.querySelector('main.flex-1');
                if (mainContent) {
                    // Remove margin/padding that might have compensated for the sidebar
                    // Example: mainContent.style.marginLeft = '0';
                }
            }
        }
    </script>
</body>

</html>