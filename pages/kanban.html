<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tablero Kanban 📋</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- SortableJS for drag-and-drop subtasks -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <link rel="stylesheet" href="../css/kanban-styles.css">
    <!-- No necesitamos cargar kanban-simple.js ya que tenemos la implementaciu00f3n completa en este archivo -->
</head>

<body class="p-4 md:p-8">
    <h1>Kanban Board Loaded</h1>

    <h1 class="text-3xl font-bold mb-4 text-left text-gray-800"><span class="emoji">📋</span>Tablero Kanban</h1>
    <p class="text-gray-600 mb-6 text-left">Organiza tus tareas arrastrándolas entre columnas. Haz clic en una tarea
        para editarla.</p>

    <div class="kanban-container">
        <div class="text-left mb-6">
            <button id="addTaskBtn"
                class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow hover:shadow-md transition duration-150 ease-in-out">
                <span class="emoji">✨</span> Añadir Nueva Tarea
            </button>
        </div>

        <div id="kanbanBoard" class="flex flex-col md:flex-row justify-between gap-4">
            <div id="todo" class="kanban-column">
                <h2 class="text-lg font-semibold mb-4 text-gray-700 border-b pb-2"><span class="emoji">📝</span>Por
                    Hacer</h2>
                <div class="kanban-tasks" data-column-id="todo"></div>
            </div>
            <div id="in-progress" class="kanban-column">
                <h2 class="text-lg font-semibold mb-4 text-gray-700 border-b pb-2"><span class="emoji">⏳</span>En
                    Progreso</h2>
                <div class="kanban-tasks" data-column-id="in-progress"></div>
            </div>
            <div id="done" class="kanban-column">
                <h2 class="text-lg font-semibold mb-4 text-gray-700 border-b pb-2"><span class="emoji">✅</span>Hecho
                </h2>
                <div class="kanban-tasks" data-column-id="done"></div>
            </div>
        </div>
    </div>

    <div id="contextMenu" class="context-menu">
        <div class="context-menu-item" data-color="bg-task-default">
            <span class="color-swatch" style="background-color: #d1d5db; border: 1px solid #9ca3af;"></span>
            Predeterminado
        </div>
        <div class="context-menu-item" data-color="bg-task-red">
            <span class="color-swatch" style="background-color: #fee2e2; border: 1px solid #fca5a5;"></span> Rojo
        </div>
        <div class="context-menu-item" data-color="bg-task-blue">
            <span class="color-swatch" style="background-color: #dbeafe; border: 1px solid #93c5fd;"></span> Azul
        </div>
        <div class="context-menu-item" data-color="bg-task-green">
            <span class="color-swatch" style="background-color: #d1fae5; border: 1px solid #6ee7b7;"></span> Verde
        </div>
        <div class="context-menu-item" data-color="bg-task-yellow">
            <span class="color-swatch" style="background-color: #fef3c7; border: 1px solid #fde047;"></span> Amarillo
        </div>
        <div class="context-menu-item" data-color="bg-task-purple">
            <span class="color-swatch" style="background-color: #e9d5ff; border: 1px solid #c4b5fd;"></span> Púrpura
        </div>
        <hr class="my-1 border-gray-200">
        <div class="context-menu-item" data-action="delete">
            <span class="emoji text-red-500">🗑️</span> <span class="text-red-600">Eliminar Tarea</span>
        </div>
    </div>

    <div id="taskModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal()">&times;</span>
            <h2 class="text-xl font-semibold mb-5"><span class="emoji">📋</span>Nueva Tarea</h2>
            <form id="taskForm">
                <div class="mb-4">
                    <label for="taskDescription"
                        class="block text-sm font-medium text-gray-700 mb-1">Descripción</label>
                    <textarea id="taskDescription" name="description" rows="3"
                        class="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border border-gray-300 rounded-md p-2"
                        placeholder="Describe la tarea..." required></textarea>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="taskDueDate" class="block text-sm font-medium text-gray-700 mb-1">Fecha de
                            Vencimiento</label>
                        <input type="date" id="taskDueDate" name="dueDate"
                            class="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border border-gray-300 rounded-md p-2">
                    </div>
                    <div>
                        <label for="taskAssignee"
                            class="block text-sm font-medium text-gray-700 mb-1">Responsable</label>
                        <input type="text" id="taskAssignee" name="assignee"
                            class="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border border-gray-300 rounded-md p-2"
                            placeholder="Nombre del responsable">
                    </div>
                </div>
                <div class="text-right mt-6">
                    <button type="button" onclick="closeModal()"
                        class="mr-2 inline-flex justify-center py-2 px-4 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                        Cancelar
                    </button>
                    <button type="submit"
                        class="inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                        Añadir Tarea
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // --- KanbanApp Module ---
        const KanbanApp = (() => {
            // --- State ---
            let currentOvcId = null; // To store the OVC context
            let columns = null; // Will be queried in init
            let contextMenu = null;
            let taskModal = null;
            let addTaskBtn = null;
            let taskForm = null;
            let draggedTask = null;
            let currentTaskElement = null; // For context menu
            let currentEditingTask = null; // For edit mode

            // --- Colores disponibles ---
            const taskColorClasses = [
                'bg-task-default', 'bg-task-red', 'bg-task-blue',
                'bg-task-green', 'bg-task-yellow', 'bg-task-purple'
            ];

            // --- Funciones ---

            function generateId(prefix = 'task') {
                return `${prefix}-` + Date.now() + '-' + Math.floor(Math.random() * 1000);
            }

            function getTaskDataFromElement(taskElement) {
                const description = taskElement.querySelector('p.font-medium')?.textContent || '';
                // Busca el texto después del emoji
                const dueDateText = taskElement.querySelector('.details p:first-child')?.textContent || '';
                const assigneeText = taskElement.querySelector('.details p:last-child:not(:first-child)')?.textContent || ''; // Asegura que sea el segundo p si existe
                const dueDate = dueDateText.includes(' ') ? dueDateText.substring(dueDateText.indexOf(' ') + 1).trim() : '';
                const assignee = assigneeText.includes(' ') ? assigneeText.substring(assigneeText.indexOf(' ') + 1).trim() : '';
                // Subtasks are not directly extracted from view mode DOM, they come from saved state
                return { description, dueDate, assignee };
            }

            /**
            * Renderiza el contenido de visualización normal de una tarjeta de tarea.
            * @param {object} taskData - Datos de la tarea (description, dueDate, assignee, subtasks).
            * @returns {string} HTML interno para la tarjeta en modo visualización.
            */
            function renderTaskViewContent(taskData) {
                const subtasks = taskData.subtasks || [];
                const completedSubtasks = subtasks.filter(st => st.completed).length;
                const totalSubtasks = subtasks.length;
                const subtasksExist = totalSubtasks > 0;

                return `
                <p class="font-medium text-gray-800">${taskData.description || 'Sin descripción'}</p>
                <div class="details mt-2 text-xs">
                    ${taskData.dueDate ? `<p class="flex items-center gap-1"><span class="emoji">📅</span> ${taskData.dueDate}</p>` : ''}
                    ${taskData.assignee ? `<p class="flex items-center gap-1 mt-1"><span class="emoji">👤</span> ${taskData.assignee}</p>` : ''}
                </div>
                ${subtasksExist ? `
                <button class="view-subtasks-btn" aria-expanded="false">
                    <span class="arrow mr-1">▶</span><span class="emoji">📑</span> Subtareas (${completedSubtasks}/${totalSubtasks})
                </button>
                <div class="subtasks-list-view" style="display: none;">
                    ${renderSubtasksView(subtasks, taskData.id)}
                </div>
                ` : ''}
            `;
            }

            /**
             * Renderiza la lista de subtareas para el modo de visualización.
             * @param {Array} subtasks - Array de objetos de subtarea.
             * @param {string} taskId - ID de la tarea padre.
             * @returns {string} HTML de la lista de subtareas.
             */
            function renderSubtasksView(subtasks, taskId) {
                if (!subtasks || subtasks.length === 0) return '<p class="text-xs text-gray-500 italic ml-1">No hay subtareas.</p>';
                return `
                <ul>
                    ${subtasks.map(subtask => `
                        <li class="subtask-item-view" data-subtask-id="${subtask.id}">
                            <input type="checkbox" ${subtask.completed ? 'checked' : ''} onchange="toggleSubtaskCompletion(event, '${taskId}', '${subtask.id}')" aria-label="Marcar subtarea ${subtask.description} como completada">
                            <span class="${subtask.completed ? 'completed' : ''}">${subtask.description}</span>
                        </li>
                    `).join('')}
                </ul>
            `;
            }

            function createTaskElement(taskData) {
                console.log(`DEBUG: Creando elemento de tarea con ID ${taskData.id}`);
                
                // Crear el elemento principal de la tarea
                const taskElement = document.createElement('div');
                taskElement.id = taskData.id;
                taskElement.classList.add('task-card');
                taskElement.draggable = true;

                // Asignar la clase de color correcta
                const colorClass = (taskData.color && taskColorClasses.includes(taskData.color)) ? taskData.color : 'bg-task-default';
                taskElement.classList.add(colorClass);

                // Almacenar datos de subtareas como propiedad (mejor que dataset para objetos complejos)
                taskElement._subtasks = Array.isArray(taskData.subtasks) ? [...taskData.subtasks] : [];
                
                // Asegurarse de que cada subtarea tenga un ID válido y estado completed
                taskElement._subtasks = taskElement._subtasks.map(st => ({
                    ...st,
                    id: st.id || generateId('sub'),
                    completed: typeof st.completed === 'boolean' ? st.completed : false
                }));

                // Renderizar el contenido HTML de la tarea
                taskElement.innerHTML = renderTaskViewContent({
                    ...taskData,
                    subtasks: taskElement._subtasks
                });

                console.log(`DEBUG: Añadiendo event listeners a tarea ${taskData.id}`);
                
                // Añadir event listeners principales
                taskElement.addEventListener('click', handleTaskClick);
                taskElement.addEventListener('dragstart', handleDragStart);
                taskElement.addEventListener('dragend', handleDragEnd);
                taskElement.addEventListener('contextmenu', handleContextMenu);

                // Delegación de eventos para botón de subtareas y clicks en checkboxes dentro de la tarjeta
                taskElement.addEventListener('click', (event) => {
                    // Alternar vista de subtareas
                    if (event.target.classList.contains('view-subtasks-btn') || event.target.closest('.view-subtasks-btn')) {
                        const button = event.target.classList.contains('view-subtasks-btn') ? event.target : event.target.closest('.view-subtasks-btn');
                        toggleSubtasksView(button);
                        event.stopPropagation(); // Evitar que se active el modo de edición de la tarea
                    }
                    
                    // Evitar el modo de edición al hacer clic en el checkbox de subtarea
                    if (event.target.matches('.subtask-item-view input[type="checkbox"]')) {
                        event.stopPropagation(); // Evitar que se active el modo de edición de la tarea
                    }
                });
                
                // Verificar que los elementos de subtareas tengan los event listeners correctos
                setTimeout(() => {
                    const subtaskCheckboxes = taskElement.querySelectorAll('.subtask-item-view input[type="checkbox"]');
                    if (subtaskCheckboxes.length > 0) {
                        console.log(`DEBUG: Encontrados ${subtaskCheckboxes.length} checkboxes de subtareas en tarea ${taskData.id}`);
                        
                        // Verificar que cada checkbox tenga el listener correcto
                        subtaskCheckboxes.forEach(checkbox => {
                            const subtaskId = checkbox.closest('.subtask-item-view').dataset.subtaskId;
                            if (!subtaskId) {
                                console.error(`ERROR: Checkbox de subtarea sin ID en tarea ${taskData.id}`);
                            }
                        });
                    }
                    
                    // Verificar que el botón de subtareas funcione correctamente
                    const subtasksButton = taskElement.querySelector('.view-subtasks-btn');
                    if (subtasksButton) {
                        console.log(`DEBUG: Botón de subtareas encontrado en tarea ${taskData.id}`);
                    }
                }, 0);
                
                console.log(`DEBUG: Elemento de tarea ${taskData.id} creado correctamente`);
                return taskElement;
            }

            function addTask(taskData, save = true) {
                // Validar y asignar valores por defecto
                if (!taskData.id) taskData.id = generateId('task');
                if (!taskData.title) taskData.title = 'Tarea sin título';
                if (!taskData.description) taskData.description = '';
                if (!taskData.columnId) taskData.columnId = 'todo';
                if (!taskData.color) taskData.color = 'bg-task-default';
                if (!Array.isArray(taskData.subtasks)) taskData.subtasks = []; // Asegurar que subtasks sea un array

                console.log(`DEBUG: Añadiendo tarea: ${JSON.stringify({
                    id: taskData.id,
                    title: taskData.title,
                    columnId: taskData.columnId,
                    subtasks: taskData.subtasks.length
                })}`);

                // Crear el elemento de la tarea
                const taskElement = createTaskElement(taskData);
                
                console.log(`DEBUG: Buscando columna para tarea ${taskData.id} con columnId=${taskData.columnId}`);
                
                // Verificar que tengamos columnas válidas
                if (!columns || columns.length === 0) {
                    console.error("ERROR: No hay columnas disponibles para añadir la tarea.");
                    console.log("Reintentando obtener columnas...");
                    columns = document.querySelectorAll('#kanbanBoard .kanban-tasks');
                    
                    if (!columns || columns.length === 0) {
                        console.error("ERROR FATAL: No se pudieron encontrar las columnas en el DOM después de reintentar.");
                        return false; // Indicar que la tarea no se pudo añadir
                    }
                }
                
                // Buscar la columna objetivo
                let targetColumn = null;
                const columnIds = ['todo', 'in-progress', 'done']; // IDs válidos de columnas
                
                // Verificar que el columnId sea válido
                if (!columnIds.includes(taskData.columnId)) {
                    console.warn(`ADVERTENCIA: ColumnId '${taskData.columnId}' no es válido, usando 'todo' como predeterminado`);
                    taskData.columnId = 'todo';
                }
                
                // Intentar múltiples métodos para encontrar la columna correcta
                // 1. Primero intentar con querySelector
                targetColumn = document.querySelector(`.kanban-tasks[data-column-id="${taskData.columnId}"]`);
                
                // 2. Si no funciona, buscar en la colección de columnas
                if (!targetColumn && columns) {
                    for (let i = 0; i < columns.length; i++) {
                        if (columns[i].dataset.columnId === taskData.columnId) {
                            targetColumn = columns[i];
                            console.log(`DEBUG: Columna '${taskData.columnId}' encontrada en el índice ${i}`);
                            break;
                        }
                    }
                }

                // 3. Si aún no se encuentra, intentar con la primera columna disponible
                if (!targetColumn && columns.length > 0) {
                    console.warn(`ADVERTENCIA: No se encontró la columna '${taskData.columnId}', usando la primera columna disponible`);
                    targetColumn = columns[0];
                    taskData.columnId = targetColumn.dataset.columnId || 'todo';
                }

                if (targetColumn) {
                    console.log(`DEBUG: Columna encontrada para '${taskData.columnId}', añadiendo tarea ${taskData.id}`);
                    
                    // Añadir la tarea a la columna
                    try {
                        targetColumn.appendChild(taskElement);
                        console.log(`DEBUG: Tarea ${taskData.id} añadida correctamente a columna '${taskData.columnId}'`);
                        
                        // Verificar que la tarea se haya añadido correctamente
                        const addedTask = document.getElementById(taskData.id);
                        if (!addedTask) {
                            console.error(`ERROR: La tarea ${taskData.id} no se encuentra en el DOM después de añadirla`);
                        }
                        
                        // Guardar el estado del tablero si es necesario
                        if (save) {
                            console.log(`DEBUG: Guardando estado del tablero después de añadir tarea ${taskData.id}`);
                            saveBoardState();
                        }
                        
                        return true; // Indicar que la tarea se añadió correctamente
                    } catch (error) {
                        console.error(`ERROR: No se pudo añadir la tarea ${taskData.id} a la columna:`, error);
                        return false; // Indicar que la tarea no se pudo añadir
                    }
                } else {
                    console.error(`ERROR FATAL: No se pudo encontrar ninguna columna válida para añadir la tarea ${taskData.id}`);
                    console.log('DEBUG: Estado actual de las columnas:');
                    if (columns) {
                        columns.forEach((col, i) => {
                            console.log(`DEBUG: Columna ${i}: id=${col.dataset.columnId || 'sin ID'}`);
                        });
                    } else {
                        console.log('DEBUG: Variable columns es null o undefined');
                    }
                    return false; // Indicar que la tarea no se pudo añadir
                }
            }

            function deleteTask(taskId) {
                const taskElement = document.getElementById(taskId);
                if (taskElement) {
                    if (currentEditingTask && currentEditingTask.id === taskId) {
                        disableEditMode(currentEditingTask, false);
                    }
                    taskElement.remove();
                    saveBoardState();
                    console.log(`Tarea ${taskId} eliminada.`);
                } else {
                    console.warn(`No se encontró la tarea con ID ${taskId} para eliminar.`);
                }
            }

            // --- Manejadores de Eventos de Edición ---

            function handleTaskClick(event) {
                const taskCard = event.currentTarget;
                // Prevent entering edit mode if the click was on the subtask section (button, list, checkbox)
                if (event.target.closest('.view-subtasks-btn') || event.target.closest('.subtasks-list-view')) {
                    return;
                }
                // Prevent entering edit mode if already editing, or if clicking edit controls, or right-click
                if (currentEditingTask || taskCard.classList.contains('editing') || event.target.closest('.edit-actions') || event.button === 2) {
                    return;
                }
                enableEditMode(taskCard);
            }

            function enableEditMode(taskElement) {
                if (currentEditingTask && currentEditingTask !== taskElement) {
                    disableEditMode(currentEditingTask, false);
                }

                currentEditingTask = taskElement;
                taskElement.classList.add('editing');
                taskElement.draggable = false;

                const originalData = getTaskDataFromElement(taskElement);
                const originalSubtasks = JSON.parse(JSON.stringify(taskElement._subtasks || [])); // Deep copy
                taskElement.dataset.originalDescription = originalData.description;
                taskElement.dataset.originalDueDate = originalData.dueDate;
                taskElement.dataset.originalAssignee = originalData.assignee;
                // Store original subtasks for cancellation
                taskElement._originalSubtasks = originalSubtasks;

                // --- Render Edit Form ---
                taskElement.innerHTML = `
                <textarea class="edit-input edit-textarea" placeholder="Descripción..." aria-label="Descripción de la tarea">${originalData.description}</textarea>
                <input type="date" class="edit-input" value="${originalData.dueDate}" aria-label="Fecha de vencimiento">
                <input type="text" class="edit-input" placeholder="Responsable..." value="${originalData.assignee}" aria-label="Responsable">

                <div class="subtasks-section">
                    <h4 class="text-sm font-medium text-gray-600 mb-2">Subtareas</h4>
                    <ul class="subtasks-list-edit mb-3" aria-label="Lista de subtareas editables">
                        ${renderSubtasksEdit(originalSubtasks)}
                    </ul>
                    <div class="add-subtask-container">
                        <input type="text" class="add-subtask-input" placeholder="Añadir nueva subtarea..." aria-label="Nueva subtarea">
                        <button type="button" class="edit-button add-subtask-btn bg-gray-200 hover:bg-gray-300 text-gray-700 border-gray-300" aria-label="Añadir subtarea">➕ Añadir</button>
                    </div>
                </div>

                <div class="edit-actions">
                    <button class="edit-button cancel-button"><span class="emoji">❌</span>Cancelar</button>
                    <button class="edit-button save-button"><span class="emoji">💾</span>Guardar</button>
                </div>
            `;
                // --- End Render Edit Form ---

                // --- Add Event Listeners for Edit Mode ---
                const subtaskListElement = taskElement.querySelector('.subtasks-list-edit');
                const addSubtaskInput = taskElement.querySelector('.add-subtask-input');
                const addSubtaskBtn = taskElement.querySelector('.add-subtask-btn');

                taskElement.querySelector('.save-button').addEventListener('click', () => disableEditMode(taskElement, true));
                taskElement.querySelector('.cancel-button').addEventListener('click', () => disableEditMode(taskElement, false));

                // Add Subtask Button
                addSubtaskBtn.addEventListener('click', () => {
                    const description = addSubtaskInput.value.trim();
                    if (description) {
                        addSubtaskToEditList(subtaskListElement, description);
                        addSubtaskInput.value = '';
                        addSubtaskInput.focus();
                    }
                });
                // Add Subtask on Enter
                addSubtaskInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault(); // Prevent form submission if inside a form
                        addSubtaskBtn.click();
                    }
                });

                // Delete Subtask Button (Event Delegation)
                subtaskListElement.addEventListener('click', (e) => {
                    if (e.target.classList.contains('subtask-delete-btn')) {
                        deleteSubtaskFromEditList(e.target.closest('.subtask-item-edit'));
                    }
                });

                // Initialize SortableJS
                Sortable.create(subtaskListElement, {
                    animation: 150,
                    ghostClass: 'sortable-ghost', // Class for the drop placeholder
                    handle: '.subtask-drag-handle', // Specify drag handle
                    forceFallback: true, // Improves compatibility
                    fallbackOnBody: true, // Prevents issues with scrolling containers
                    swapThreshold: 0.65
                });
                // --- End Event Listeners ---

                taskElement.querySelector('textarea').focus();
                document.addEventListener('click', handleClickOutsideEdit, true);
            }

            function disableEditMode(taskElement, saveData) {
                if (!taskElement || !taskElement.classList.contains('editing')) return;

                let updatedData = {};

                if (saveData) {
                    const newDescription = taskElement.querySelector('textarea').value.trim();
                    const newDueDate = taskElement.querySelector('input[type="date"]').value;
                    const newAssignee = taskElement.querySelector('input[type="text"]').value.trim();
                    if (!newDescription) {
                        alert("La descripción no puede estar vacía.");
                        taskElement.querySelector('textarea').focus();
                        return;
                    }
                    updatedData = {
                        description: newDescription,
                        dueDate: newDueDate,
                        assignee: newAssignee,
                        subtasks: getSubtasksFromEditList(taskElement.querySelector('.subtasks-list-edit'))
                    };
                    taskElement._subtasks = updatedData.subtasks; // Update internal data
                } else {
                    // Restore from original data stored on the element
                    updatedData = {
                        description: taskElement.dataset.originalDescription,
                        dueDate: taskElement.dataset.originalDueDate,
                        assignee: taskElement.dataset.originalAssignee,
                        subtasks: taskElement._originalSubtasks || []
                    };
                    taskElement._subtasks = updatedData.subtasks; // Restore internal data
                }

                // Restaurar vista normal usando la función actualizada
                taskElement.innerHTML = renderTaskViewContent(updatedData);
                taskElement.classList.remove('editing');
                taskElement.draggable = true;

                delete taskElement.dataset.originalDescription;
                delete taskElement.dataset.originalDueDate;
                delete taskElement.dataset.originalAssignee;
                delete taskElement._originalSubtasks; // Clean up stored original subtasks

                // Re-attach core listeners
                taskElement.addEventListener('click', handleTaskClick);
                taskElement.addEventListener('dragstart', handleDragStart);
                taskElement.addEventListener('dragend', handleDragEnd);
                taskElement.addEventListener('contextmenu', handleContextMenu);
                // The listener attached in createTaskElement handles subtask toggling via delegation.


                currentEditingTask = null;
                document.removeEventListener('click', handleClickOutsideEdit, true);

                if (saveData) {
                    saveBoardState(); // Save the entire board state including the updated task
                }
            }

            function handleClickOutsideEdit(event) {
                // Ignore clicks inside the context menu or the task being edited
                if (contextMenu.contains(event.target) || (currentEditingTask && currentEditingTask.contains(event.target))) {
                    return;
                }
                // If a task is being edited and the click is outside, cancel the edit
                if (currentEditingTask) {
                    // Check if the click was on a SortableJS helper element (often added to body)
                    if (event.target.closest('.sortable-fallback') || event.target.closest('.sortable-ghost')) {
                        return;
                    }
                    disableEditMode(currentEditingTask, false);
                }
            }

            // --- Subtask Helper Functions ---

            /**
             * Renders the list of subtasks for the edit mode.
             * @param {Array} subtasks - Array of subtask objects.
             * @returns {string} HTML string for the list items.
             */
            function renderSubtasksEdit(subtasks) {
                if (!subtasks || subtasks.length === 0) return '<p class="text-xs text-gray-500 italic px-1">No hay subtareas añadidas.</p>';
                return subtasks.map(subtask => `
                <li class="subtask-item-edit" data-subtask-id="${subtask.id}" data-completed="${subtask.completed}">
                    <span class="subtask-drag-handle" title="Arrastrar para reordenar">⠿</span>
                    <input type="text" value="${subtask.description}" placeholder="Descripción subtarea..." aria-label="Descripción de la subtarea ${subtask.description}">
                    <button type="button" class="subtask-delete-btn" title="Eliminar subtarea">✖</button>
                </li>
            `).join('');
            }

            /**
             * Adds a new subtask item to the edit list in the DOM.
             * @param {HTMLElement} listElement - The UL element for subtasks.
             * @param {string} description - The description of the new subtask.
             */
            function addSubtaskToEditList(listElement, description) {
                // Remove the "No hay subtareas" message if it exists
                const noSubtasksMsg = listElement.querySelector('p');
                if (noSubtasksMsg) noSubtasksMsg.remove();

                const newSubtaskId = generateId('sub');
                const newSubtask = { id: newSubtaskId, description: description, completed: false };
                const li = document.createElement('li');
                li.className = 'subtask-item-edit';
                li.dataset.subtaskId = newSubtask.id;
                li.dataset.completed = 'false'; // New tasks are not completed
                li.innerHTML = `
                <span class="subtask-drag-handle" title="Arrastrar para reordenar">⠿</span>
                <input type="text" value="${newSubtask.description}" placeholder="Descripción subtarea..." aria-label="Descripción de la subtarea ${newSubtask.description}">
                <button type="button" class="subtask-delete-btn" title="Eliminar subtarea">✖</button>
            `;
                listElement.appendChild(li);
            }

            /**
             * Removes a subtask item from the edit list in the DOM.
             * @param {HTMLElement} subtaskItemElement - The LI element to remove.
             */
            function deleteSubtaskFromEditList(subtaskItemElement) {
                const listElement = subtaskItemElement.parentElement;
                subtaskItemElement.remove();
                // If list is now empty, add back the placeholder message
                if (listElement && !listElement.querySelector('.subtask-item-edit')) {
                    listElement.innerHTML = '<p class="text-xs text-gray-500 italic px-1">No hay subtareas añadidas.</p>';
                }
            }

            /**
             * Retrieves the current state of subtasks from the edit list DOM, preserving order.
             * @param {HTMLElement} listElement - The UL element containing subtask items.
             * @returns {Array} Array of subtask objects.
             */
            function getSubtasksFromEditList(listElement) {
                const subtaskItems = listElement.querySelectorAll('.subtask-item-edit');
                const subtasks = [];
                subtaskItems.forEach(item => {
                    const input = item.querySelector('input[type="text"]');
                    const description = input ? input.value.trim() : '';
                    // Only add if description is not empty
                    if (description) {
                        subtasks.push({
                            id: item.dataset.subtaskId,
                            description: description,
                            // Preserve completed status from original data stored in data-completed attribute
                            completed: item.dataset.completed === 'true'
                        });
                    } else {
                        console.warn("Subtarea vacía encontrada y omitida al guardar:", item.dataset.subtaskId);
                    }
                });
                return subtasks;
            }

            /**
             * Toggles the visibility of the subtask list in view mode.
             * @param {HTMLElement} button - The button that was clicked.
             */
            function toggleSubtasksView(button) {
                const subtaskList = button.nextElementSibling; // Assumes list is immediately after button
                const isExpanded = button.getAttribute('aria-expanded') === 'true';
                const arrow = button.querySelector('.arrow');
                if (subtaskList) {
                    subtaskList.style.display = isExpanded ? 'none' : 'block';
                    button.setAttribute('aria-expanded', !isExpanded);
                    if (arrow) {
                        // arrow.textContent = isExpanded ? '▶' : '▼'; // Change arrow direction
                        arrow.style.transform = isExpanded ? 'rotate(0deg)' : 'rotate(90deg)';
                    }
                }
            }

            /**
             * Handles the change event for subtask completion checkboxes. Saves state.
             * @param {Event} event - The change event.
             * @param {string} taskId - The ID of the parent task.
             * @param {string} subtaskId - The ID of the subtask being toggled.
             */
            function toggleSubtaskCompletion(event, taskId, subtaskId) {
                const isChecked = event.target.checked;
                const taskElement = document.getElementById(taskId);
                if (taskElement && taskElement._subtasks) {
                    const subtaskIndex = taskElement._subtasks.findIndex(st => st.id === subtaskId);
                    if (subtaskIndex !== -1) {
                        taskElement._subtasks[subtaskIndex].completed = isChecked;

                        // Update the view immediately
                        const subtaskSpan = event.target.nextElementSibling; // Assumes span is next sibling
                        if (subtaskSpan) {
                            subtaskSpan.classList.toggle('completed', isChecked);
                        }
                        // Update the summary button text
                        const viewButton = taskElement.querySelector('.view-subtasks-btn');
                        if (viewButton) {
                            const completedCount = taskElement._subtasks.filter(st => st.completed).length;
                            const totalCount = taskElement._subtasks.length;
                            viewButton.innerHTML = `<span class="arrow mr-1" style="transform: ${viewButton.getAttribute('aria-expanded') === 'true' ? 'rotate(90deg)' : 'rotate(0deg)'};">▶</span><span class="emoji">📑</span> Subtareas (${completedCount}/${totalCount})`;
                        }

                        saveBoardState(); // Save changes immediately after toggle
                    } else {
                        console.error("Subtask not found in internal data:", subtaskId, "for task:", taskId);
                    }
                } else {
                    console.error("Task element or internal subtask data not found:", taskId);
                }
            }

            // --- Manejadores Drag & Drop (sin cambios lógicos) ---
            function handleDragStart(event) {
                if (event.target.classList.contains('editing')) {
                    event.preventDefault(); return;
                }
                if (event.target.classList.contains('task-card')) {
                    draggedTask = event.target;
                    event.dataTransfer.setData('text/plain', event.target.id);
                    event.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => { if (draggedTask) draggedTask.classList.add('dragging'); }, 0);
                } else {
                    event.preventDefault();
                }
            }
            function handleDragEnd(event) {
                if (draggedTask) draggedTask.classList.remove('dragging');
                columns.forEach(col => col.classList.remove('drag-over'));
                draggedTask = null;
            }
            function handleDragOver(event) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
                const targetColumn = event.target.closest('.kanban-tasks');
                if (targetColumn && (!draggedTask || !targetColumn.contains(draggedTask))) {
                    columns.forEach(col => col !== targetColumn && col.classList.remove('drag-over'));
                    targetColumn.classList.add('drag-over');
                }
            }
            function handleDragEnter(event) {
                event.preventDefault();
                const targetColumn = event.target.closest('.kanban-tasks');
                if (targetColumn && (!draggedTask || !targetColumn.contains(draggedTask))) {
                    targetColumn.classList.add('drag-over');
                }
            }
            function handleDragLeave(event) {
                const targetColumn = event.target.closest('.kanban-tasks');
                if (targetColumn && !targetColumn.contains(event.relatedTarget)) {
                    targetColumn.classList.remove('drag-over');
                }
                if (!event.relatedTarget || !event.relatedTarget.closest('.kanban-tasks')) {
                    columns.forEach(col => col.classList.remove('drag-over'));
                }
            }
            function handleDrop(event) {
                event.preventDefault();
                const targetColumn = event.target.closest('.kanban-tasks');
                if (targetColumn && draggedTask && targetColumn !== draggedTask.parentElement) {
                    // Prevenir drop si la columna destino es la misma que origen (ya filtrado en dragover/enter?)
                    // if (targetColumn === draggedTask.parentElement) {
                    //      if(targetColumn) targetColumn.classList.remove('drag-over');
                    //      return;
                    // }
                    targetColumn.appendChild(draggedTask);
                    saveBoardState();
                }
                if (targetColumn) targetColumn.classList.remove('drag-over');
            }

            // --- Manejadores Menú Contextual (sin cambios lógicos) ---
            function handleContextMenu(event) {
                if (event.currentTarget.classList.contains('editing')) {
                    event.preventDefault(); return;
                }
                event.preventDefault();
                currentTaskElement = event.currentTarget;
                if (!currentTaskElement) return;
                // Lógica de posicionamiento (sin cambios)
                const { clientX: mouseX, clientY: mouseY } = event;
                contextMenu.style.display = 'block';
                const { offsetWidth: menuWidth, offsetHeight: menuHeight } = contextMenu;
                const { innerWidth, innerHeight } = window;
                let top = mouseY, left = mouseX;
                if (mouseY + menuHeight > innerHeight) top = mouseY - menuHeight;
                if (mouseX + menuWidth > innerWidth) left = mouseX - menuWidth;
                if (top < 0) top = 5;
                if (left < 0) left = 5;
                contextMenu.style.top = `${top}px`;
                contextMenu.style.left = `${left}px`;
                // Listeners de cierre (sin cambios)
                setTimeout(() => {
                    document.addEventListener('click', closeContextMenuOnClickOutside, { capture: true, once: true });
                    document.addEventListener('keydown', closeContextMenuOnEscape, { once: true });
                }, 0);
            }
            function closeContextMenu() {
                contextMenu.style.display = 'none';
                currentTaskElement = null;
                document.removeEventListener('click', closeContextMenuOnClickOutside, { capture: true });
                document.removeEventListener('keydown', closeContextMenuOnEscape);
            }
            function closeContextMenuOnClickOutside(event) {
                // Evitar cierre si se hizo clic en la tarea que se está editando
                if (currentEditingTask && currentEditingTask.contains(event.target)) {
                    // Re-añadir listener si no se cerró
                    document.addEventListener('click', closeContextMenuOnClickOutside, { capture: true, once: true });
                    return;
                }
                if (!contextMenu.contains(event.target)) {
                    closeContextMenu();
                } else {
                    // Re-añadir listener si se hizo clic dentro del menú pero no se cerró
                    document.addEventListener('click', closeContextMenuOnClickOutside, { capture: true, once: true });
                }
            }
            function closeContextMenuOnEscape(event) {
                if (event.key === 'Escape') {
                    closeContextMenu();
                } else {
                    document.addEventListener('keydown', closeContextMenuOnEscape, { once: true });
                }
            }
            function handleContextMenuAction(event) {
                const menuItem = event.target.closest('.context-menu-item');
                if (!menuItem || !currentTaskElement) {
                    if (!menuItem && contextMenu.contains(event.target)) {
                        // No cerrar automáticamente si se hace clic en padding? Opcional.
                    }
                    return;
                }
                const color = menuItem.dataset.color;
                const action = menuItem.dataset.action;
                if (color) {
                    taskColorClasses.forEach(cls => currentTaskElement.classList.remove(cls));
                    currentTaskElement.classList.add(color);
                    saveBoardState();
                } else if (action === 'delete') {
                    const taskDescription = getTaskDataFromElement(currentTaskElement).description || 'esta tarea';
                    if (confirm(`¿Estás seguro de que quieres eliminar "${taskDescription}"?`)) {
                        deleteTask(currentTaskElement.id);
                    }
                }
                closeContextMenu(); // Cerrar siempre después de una acción válida
            }

            // --- Manejadores Modal (sin cambios lógicos) ---
            function openModal() {
                taskForm.reset();
                taskModal.style.display = 'block';
                document.getElementById('taskDescription').focus();
            }
            function closeModal() {
                taskModal.style.display = 'none';
            }
            function handleFormSubmit(event) {
                event.preventDefault();
                const formData = new FormData(taskForm);
                const taskData = {
                    description: formData.get('description').trim(),
                    dueDate: formData.get('dueDate'),
                    assignee: formData.get('assignee').trim(),
                };
                if (!taskData.description) {
                    alert("La descripción de la tarea no puede estar vacía.");
                    document.getElementById('taskDescription').focus();
                    return;
                }
                addTask(taskData);
                closeModal();
            }

            // --- Persistencia (LocalStorage) ---

            /**
             * Generates the localStorage key based on the current OVC ID.
             * @returns {string} The localStorage key.
             */
            function getStorageKey() {
                const baseKey = 'kanbanBoardState_v3'; // Keep version suffix for potential future migrations
                return currentOvcId ? `${baseKey}_${currentOvcId}` : baseKey; // Use specific key if OVC ID exists
            }

            function saveBoardState() {
                const storageKey = getStorageKey(); // Get dynamic key
                if (currentEditingTask) {
                    console.warn("Guardando con tarea en edición. Cancelando edición...");
                    disableEditMode(currentEditingTask, false);
                }
                const boardState = [];
                if (!columns) { // Ensure columns are queried
                    console.error("Error saving: Columns not initialized.");
                    return;
                }
                columns.forEach(column => {
                    const columnId = column.dataset.columnId;
                    const tasks = column.querySelectorAll('.task-card');
                    tasks.forEach((taskElement, index) => {
                        if (taskElement.classList.contains('editing')) {
                            console.error("Error crítico: Guardando tarea aún en modo edición:", taskElement.id);
                            return;
                        }
                        let taskColor = taskColorClasses.find(cls => taskElement.classList.contains(cls)) || 'bg-task-default';
                        const taskData = getTaskDataFromElement(taskElement);
                        const subtasks = taskElement._subtasks || [];
                        boardState.push({
                            id: taskElement.id,
                            description: taskData.description,
                            dueDate: taskData.dueDate,
                            assignee: taskData.assignee,
                            color: taskColor,
                            columnId: columnId,
                            order: index,
                            subtasks: subtasks
                        });
                    });
                });
                // Sorting logic remains the same
                boardState.sort((a, b) => {
                    const columnOrder = ['todo', 'in-progress', 'done'];
                    const columnAIndex = columnOrder.indexOf(a.columnId);
                    const columnBIndex = columnOrder.indexOf(b.columnId);
                    if (columnAIndex !== columnBIndex) return columnAIndex - columnBIndex;
                    return (a.order || 0) - (b.order || 0);
                });
                try {
                    localStorage.setItem(storageKey, JSON.stringify(boardState));
                    console.log(`Estado del tablero guardado en ${storageKey}.`);
                } catch (error) {
                    console.error(`Error al guardar en localStorage (${storageKey}):`, error);
                    alert("No se pudo guardar el estado del tablero.");
                }
            }

            function loadBoardState() {
                const storageKey = getStorageKey(); // Obtener clave dinámica
                console.log(`DEBUG: Cargando estado del tablero desde ${storageKey}...`);
                
                // Verificar que las columnas estén inicializadas
                if (!columns || !columns.length) {
                    console.error("Error loading: Columns not initialized.");
                    console.log("Reintentando obtener columnas...");
                    columns = document.querySelectorAll('#kanbanBoard .kanban-tasks');
                    if (!columns || !columns.length) {
                        console.error("Error crítico: No se pudieron encontrar las columnas en el DOM.");
                        // Intentar nuevamente después de un breve retraso
                        setTimeout(() => {
                            console.log("Reintentando obtener columnas después de un retraso...");
                            columns = document.querySelectorAll('#kanbanBoard .kanban-tasks');
                            if (columns && columns.length) {
                                console.log("Columnas encontradas después del retraso. Continuando carga...");
                                loadBoardState(); // Intentar cargar de nuevo
                            } else {
                                console.error("Error fatal: No se pudieron encontrar las columnas después de múltiples intentos.");
                            }
                        }, 300);
                        return;
                    }
                }
                
                // Mostrar información de depuración sobre las columnas
                console.log(`DEBUG: Columnas encontradas: ${columns.length}`);
                columns.forEach((col, index) => {
                    console.log(`DEBUG: Columna ${index}: id=${col.dataset.columnId}`);
                });
                
                // Limpiar las tareas existentes primero
                columns.forEach(col => {
                    // Guardar el ID de la columna antes de limpiarla
                    const columnId = col.dataset.columnId;
                    console.log(`DEBUG: Limpiando columna ${columnId}`);
                    col.innerHTML = '';
                });

                // Cargar tareas desde localStorage
                let savedState = null;
                try {
                    savedState = localStorage.getItem(storageKey);
                } catch (error) {
                    console.error(`ERROR: No se pudo acceder a localStorage para la clave ${storageKey}:`, error);
                }
                
                // Si no hay estado guardado, crear tareas de ejemplo
                if (!savedState) {
                    console.log(`DEBUG: No hay estado guardado en ${storageKey}, creando tareas de ejemplo.`);
                    // Crear algunas tareas de ejemplo
                    /* const exampleTasks = [
                        {
                            id: generateId('task'),
                            title: 'Ejemplo: Crear documentación',
                            description: 'Crear documentación para el proyecto',
                            columnId: 'todo',
                            color: 'bg-task-default',
                            subtasks: [
                                { id: generateId('sub'), description: 'Escribir introducción', completed: false },
                                { id: generateId('sub'), description: 'Documentar API', completed: false }
                            ]
                        },
                        {
                            id: generateId('task'),
                            title: 'Ejemplo: Diseñar interfaz',
                            description: 'Crear mockups para la interfaz de usuario',
                            columnId: 'in-progress',
                            color: 'bg-task-blue',
                            subtasks: [
                                { id: generateId('sub'), description: 'Diseñar página principal', completed: true },
                                { id: generateId('sub'), description: 'Diseñar panel de control', completed: false }
                            ]
                        },
                        {
                            id: generateId('task'),
                            title: 'Ejemplo: Investigar tecnologías',
                            description: 'Investigar nuevas tecnologías para el proyecto',
                            columnId: 'done',
                            color: 'bg-task-green',
                            subtasks: [
                                { id: generateId('sub'), description: 'Investigar frameworks', completed: true },
                                { id: generateId('sub'), description: 'Evaluar opciones', completed: true }
                            ]
                        }
                    ];
                    
                    // Guardar tareas de ejemplo en localStorage
                    try {
                        localStorage.setItem(storageKey, JSON.stringify(exampleTasks));
                        savedState = localStorage.getItem(storageKey);
                        console.log(`DEBUG: Tareas de ejemplo guardadas en ${storageKey}`);
                    } catch (error) {
                        console.error(`ERROR: No se pudieron guardar las tareas de ejemplo en localStorage:`, error);
                        savedState = JSON.stringify(exampleTasks); // Usar directamente sin guardar en localStorage
                    } */
                }
                
                if (savedState) {
                    try {
                        let boardState = JSON.parse(savedState);
                        console.log(`DEBUG: Tareas cargadas: ${boardState.length}`);
                        
                        // Validar que boardState sea un array
                        if (!Array.isArray(boardState)) {
                            console.error(`ERROR: El estado cargado no es un array válido`);
                            boardState = [];
                        }
                        
                        // Ordenar tareas por columna y orden
                        boardState.sort((a, b) => {
                            const columnOrder = ['todo', 'in-progress', 'done'];
                            const columnAIndex = columnOrder.indexOf(a.columnId);
                            const columnBIndex = columnOrder.indexOf(b.columnId);
                            if (columnAIndex === -1) return 1;
                            if (columnBIndex === -1) return -1;
                            if (columnAIndex !== columnBIndex) return columnAIndex - columnBIndex;
                            return (a.order || 0) - (b.order || 0);
                        });

                        // Añadir cada tarea al tablero
                        let tasksAdded = 0;
                        let tasksWithErrors = 0;
                        
                        boardState.forEach(taskData => {
                            try {
                                // Validar y corregir datos de la tarea
                                if (!taskData.id) {
                                    console.log(`DEBUG: Tarea sin ID, generando uno nuevo`);
                                    taskData.id = generateId('task');
                                }
                                
                                if (!taskData.title) {
                                    console.log(`DEBUG: Tarea ${taskData.id} sin título, asignando uno por defecto`);
                                    taskData.title = 'Tarea sin título';
                                }
                                
                                // Asegurarse de que la tarea tenga una columna válida
                                if (!taskData.columnId) {
                                    console.log(`DEBUG: Tarea ${taskData.id} sin columnId, asignando 'todo'`);
                                    taskData.columnId = 'todo';
                                }
                                
                                // Verificar que la columna exista
                                const targetColumn = Array.from(columns).find(col => col.dataset.columnId === taskData.columnId);
                                if (!targetColumn) {
                                    console.log(`DEBUG: Columna ${taskData.columnId} no encontrada para tarea ${taskData.id}, usando 'todo'`);
                                    taskData.columnId = 'todo';
                                }
                                
                                // Asegurarse de que las subtareas tengan IDs válidos y estado completed
                                taskData.subtasks = Array.isArray(taskData.subtasks) ? taskData.subtasks : [];
                                taskData.subtasks = taskData.subtasks.map(st => ({
                                    ...st,
                                    id: st.id || generateId('sub'),
                                    description: st.description || 'Subtarea sin descripción',
                                    completed: typeof st.completed === 'boolean' ? st.completed : false
                                }));
                                
                                // Añadir la tarea al tablero
                                console.log(`DEBUG: Añadiendo tarea ${taskData.id} a columna ${taskData.columnId}`);
                                addTask(taskData, false); // Añadir tarea sin disparar otro guardado
                                tasksAdded++;
                            } catch (taskError) {
                                console.error(`ERROR: No se pudo añadir la tarea ${taskData.id || 'desconocida'}:`, taskError);
                                tasksWithErrors++;
                            }
                        });
                        
                        console.log(`DEBUG: Estado del tablero cargado desde ${storageKey}. Tareas añadidas: ${tasksAdded}, con errores: ${tasksWithErrors}`);
                        
                        // Verificar que se hayan añadido tareas correctamente
                        if (tasksAdded === 0 && boardState.length > 0) {
                            console.error(`ERROR: No se pudo añadir ninguna tarea a pesar de tener ${boardState.length} en el estado`);
                        }
                        
                        // Configurar listeners para las tareas recién añadidas
                        document.querySelectorAll('.task-card').forEach(taskCard => {
                            console.log(`DEBUG: Verificando listeners para tarea ${taskCard.id}`);
                            // Asegurarse de que la tarea tenga el listener de menú contextual
                            if (!taskCard._hasContextMenuListener) {
                                taskCard.addEventListener('contextmenu', handleContextMenu);
                                taskCard._hasContextMenuListener = true;
                            }
                        });
                        
                    } catch (error) {
                        console.error(`ERROR: Error al cargar el estado del tablero desde ${storageKey}:`, error);
                        
                        // Intentar limpiar datos corruptos
                        try {
                            localStorage.removeItem(storageKey);
                            console.log(`DEBUG: Datos corruptos eliminados de localStorage`);
                        } catch (removeError) {
                            console.error(`ERROR: No se pudieron eliminar datos corruptos:`, removeError);
                        }
                        
                        // Intentar cargar de nuevo con un tablero vacío
                        setTimeout(() => loadBoardState(), 200);
                    }
                } else {
                    console.error(`ERROR: No se pudo cargar el estado del tablero desde ${storageKey}.`);
                }
            }

            // --- Inicialización ---
            /**
             * Initializes the Kanban board application.
             * @param {string|null} ovcIdContext - The ID of the OVC to load the board for.
             * @param {string} [ovcTitle=''] - The title of the OVC to display.
             */
            function init(ovcIdContext = null, ovcTitle = '') {
                console.log(`KanbanApp.init called. Context OVC ID: ${ovcIdContext}, Title: ${ovcTitle}`);
                
                // Validar que se proporcione un ID de OVC
                if (!ovcIdContext) {
                    //console.error('Error: Se requiere un ID de OVC para inicializar el tablero Kanban');
                    // Mostrar mensaje de error al usuario
                    const errorContainer = document.createElement('div');
                    errorContainer.className = 'p-4 bg-red-100 border-l-4 border-red-500 text-red-700';
                    errorContainer.role = 'alert';
                    errorContainer.innerHTML = `
                        <p class="font-bold">Error</p>
                        <p>No se pudo cargar el tablero Kanban. No se proporcionó un ID de OVC válido.</p>
                        <p class="text-sm mt-2">Por favor, asegúrate de acceder al tablero Kanban desde la lista de OVCs.</p>
                    `;
                    //document.body.insertBefore(errorContainer, document.body.firstChild);
                    return;
                }
                
                currentOvcId = ovcIdContext; // Store the OVC ID
                
                // Actualizar el título en la interfaz si se proporciona
                if (ovcTitle) {
                    const titleElement = document.querySelector('h1.text-3xl');
                    if (titleElement) {
                        titleElement.textContent = `Tablero Kanban - ${ovcTitle}`;
                    }
                }
                
                // Marcar que la inicialización ha comenzado
                window.kanbanInitialized = true;

                // Query DOM elements *after* the content is loaded into index.html
                columns = document.querySelectorAll('#kanbanBoard .kanban-tasks');
                contextMenu = document.getElementById('contextMenu');
                taskModal = document.getElementById('taskModal');
                addTaskBtn = document.getElementById('addTaskBtn');
                taskForm = document.getElementById('taskForm');

                console.log('DEBUG: Elementos del DOM encontrados:', {
                    columns: columns.length,
                    contextMenu: !!contextMenu,
                    taskModal: !!taskModal,
                    addTaskBtn: !!addTaskBtn,
                    taskForm: !!taskForm
                });

                if (!columns.length || !contextMenu || !taskModal || !addTaskBtn || !taskForm) {
                    console.error("Error: Uno o más elementos esenciales del Kanban no se encontraron en el DOM. La inicialización falló.");
                    
                    // Mostrar mensaje de error al usuario
                    const errorContainer = document.createElement('div');
                    errorContainer.className = 'p-4 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700';
                    errorContainer.role = 'alert';
                    errorContainer.innerHTML = `
                        <p class="font-bold">Advertencia</p>
                        <p>Algunos elementos del tablero Kanban no se cargaron correctamente.</p>
                        <p class="text-sm mt-2">Recargando la página en 3 segundos...</p>
                    `;
                    document.body.insertBefore(errorContainer, document.body.firstChild);
                    
                    // Intentar de nuevo después de un retraso
                    setTimeout(() => {
                        console.log("Reintentando carga del DOM...");
                        columns = document.querySelectorAll('#kanbanBoard .kanban-tasks');
                        contextMenu = document.getElementById('contextMenu');
                        taskModal = document.getElementById('taskModal');
                        addTaskBtn = document.getElementById('addTaskBtn');
                        taskForm = document.getElementById('taskForm');
                        console.log('DEBUG: Segundo intento de encontrar elementos:', {
                            columns: columns.length,
                            contextMenu: !!contextMenu,
                            taskModal: !!taskModal,
                            addTaskBtn: !!addTaskBtn,
                            taskForm: !!taskForm
                        });
                        if (!columns.length || !contextMenu || !taskModal || !addTaskBtn || !taskForm) {
                            console.error("Reintento fallido. Elementos del Kanban aún faltantes.");
                            
                            // Actualizar mensaje de error
                            errorContainer.className = 'p-4 bg-red-100 border-l-4 border-red-500 text-red-700';
                            errorContainer.innerHTML = `
                                <p class="font-bold">Error crítico</p>
                                <p>No se pudo cargar el tablero Kanban. Elementos esenciales faltantes.</p>
                                <p class="text-sm mt-2">Por favor, recarga la página o contacta al soporte técnico.</p>
                            `;
                            
                            return; // Detener la inicialización si faltan elementos
                        } else {
                            console.log("Reintento exitoso. Continuando con la inicialización.");
                            // Eliminar mensaje de error si existe
                            if (errorContainer && errorContainer.parentNode) {
                                errorContainer.parentNode.removeChild(errorContainer);
                            }
                            setupListenersAndLoad();
                        }
                    }, 3000); // Esperar 3 segundos antes de reintentar
                    return; // Detener el intento inicial
                }

                setupListenersAndLoad();
            }

            function setupListenersAndLoad() {
                console.log("Setting up listeners and loading board state...");
                
                // Asegurarse de que todos los elementos DOM estén disponibles
                if (!columns || !columns.length) {
                    console.log("Reintentando obtener columnas en setupListenersAndLoad...");
                    columns = document.querySelectorAll('#kanbanBoard .kanban-tasks');
                }
                
                if (!contextMenu) {
                    console.log("Reintentando obtener contextMenu en setupListenersAndLoad...");
                    contextMenu = document.getElementById('contextMenu');
                }
                
                if (!taskModal) {
                    console.log("Reintentando obtener taskModal en setupListenersAndLoad...");
                    taskModal = document.getElementById('taskModal');
                }
                
                if (!addTaskBtn) {
                    console.log("Reintentando obtener addTaskBtn en setupListenersAndLoad...");
                    addTaskBtn = document.getElementById('addTaskBtn');
                }
                
                if (!taskForm) {
                    console.log("Reintentando obtener taskForm en setupListenersAndLoad...");
                    taskForm = document.getElementById('taskForm');
                }
                
                // Verificar nuevamente si tenemos todos los elementos necesarios
                if (!columns.length || !contextMenu || !taskModal || !addTaskBtn || !taskForm) {
                    console.error("Error: Aún faltan elementos esenciales del Kanban. Reintentando en 200ms...");
                    setTimeout(setupListenersAndLoad, 200);
                    return;
                }
                
                // Eliminar listeners previos para evitar duplicados si init se llama múltiples veces
                document.removeEventListener('click', closeContextMenuOnClickOutside, { capture: true });
                document.removeEventListener('keydown', closeContextMenuOnEscape);
                window.removeEventListener('click', closeModalOnWindowClick);
                window.removeEventListener('keydown', handleEscapeKey);

                // Clonar elementos para eliminar listeners antiguos de manera efectiva
                if (contextMenu) {
                    const newContextMenu = contextMenu.cloneNode(true);
                    contextMenu.parentNode.replaceChild(newContextMenu, contextMenu);
                    contextMenu = newContextMenu;
                }
                
                if (addTaskBtn) {
                    const newAddTaskBtn = addTaskBtn.cloneNode(true);
                    addTaskBtn.parentNode.replaceChild(newAddTaskBtn, addTaskBtn);
                    addTaskBtn = newAddTaskBtn;
                }
                
                if (taskForm) {
                    const newTaskForm = taskForm.cloneNode(true);
                    taskForm.parentNode.replaceChild(newTaskForm, taskForm);
                    taskForm = newTaskForm;
                }

                // Configurar Drag and Drop para columnas usando SortableJS
                console.log(`DEBUG: Configurando SortableJS para ${columns.length} columnas`);
                columns.forEach((column, index) => {
                    console.log(`DEBUG: Configurando columna ${index}: ${column.dataset.columnId}`);
                    
                    // Destruir instancia existente si se está reinicializando
                    if (column.sortableInstance) {
                        console.log(`DEBUG: Destruyendo instancia anterior de SortableJS para columna ${column.dataset.columnId}`);
                        column.sortableInstance.destroy();
                    }
                    
                    try {
                        column.sortableInstance = new Sortable(column, {
                            group: 'kanban',
                            animation: 150,
                            ghostClass: 'dragging',
                            onEnd: function (evt) {
                                console.log(`DEBUG: Tarea movida en columna ${column.dataset.columnId}`);
                                saveBoardState(); // Guardar estado después de mover la tarea
                            }
                        });
                        console.log(`DEBUG: SortableJS configurado correctamente para columna ${column.dataset.columnId}`);
                    } catch (error) {
                        console.error(`ERROR: No se pudo configurar SortableJS para columna ${column.dataset.columnId}:`, error);
                    }
                });

                // Configurar listeners del menú contextual
                if (contextMenu) {
                    console.log('DEBUG: Configurando listeners para menú contextual');
                    contextMenu.addEventListener('click', handleContextMenuAction);
                    
                    // Configurar listeners para todas las tareas existentes
                    document.querySelectorAll('.task-card').forEach(taskCard => {
                        taskCard.addEventListener('contextmenu', handleContextMenu);
                    });
                } else { 
                    console.error("Context menu element not found for listener setup."); 
                }
                
                // Configurar listeners para el modal
                if (addTaskBtn) {
                    console.log('DEBUG: Configurando listener para botón de añadir tarea');
                    addTaskBtn.addEventListener('click', openModal);
                } else { 
                    console.error("Add task button not found for listener setup."); 
                }

                if (taskForm) {
                    console.log('DEBUG: Configurando listener para formulario de tarea');
                    taskForm.addEventListener('submit', handleFormSubmit);
                    
                    // También configurar el botón de cerrar modal
                    const closeButton = taskModal.querySelector('.close-button');
                    if (closeButton) {
                        closeButton.addEventListener('click', closeModal);
                    }
                } else { 
                    console.error("Task form not found for listener setup."); 
                }

                // Listeners globales para cerrar modal y tecla escape
                window.addEventListener('click', closeModalOnWindowClick);
                window.addEventListener('keydown', handleEscapeKey);

                console.log('DEBUG: Todos los listeners configurados correctamente');
                
                // Cargar estado inicial para el OVC específico
                console.log('DEBUG: Cargando estado del tablero...');
                loadBoardState();
                
                console.log('DEBUG: Inicialización de Kanban completada con éxito');
            }

            // Helper for window click listener
            function closeModalOnWindowClick(event) {
                if (taskModal && event.target == taskModal) {
                    closeModal();
                }
            }
            // Helper for escape key listener
            function handleEscapeKey(event) {
                if (event.key === 'Escape') {
                    if (taskModal && taskModal.style.display === 'block') closeModal();
                    else if (currentEditingTask) disableEditMode(currentEditingTask, false);
                    else if (contextMenu && contextMenu.style.display === 'block') closeContextMenu();
                }
            }


            // --- Public API ---
            const publicApi = {
                init: init,
                // Expose other methods only if strictly necessary for external interaction
                _instance: null // Add a reference to the instance if needed
            };

            // Store the instance in the global scope
            window.KanbanApp = publicApi;
            
            // Initialize the instance reference
            publicApi._instance = publicApi;
            
            console.log('KanbanApp expuesto en el objeto window');
            
            // Notificar a la ventana principal que el Kanban está listo
            if (window.parent) {
                console.log('Enviando mensaje KANBAN_READY a la ventana principal');
                window.parent.postMessage({ type: 'KANBAN_READY' }, '*');
            } else {
                console.log('No se encontró ventana padre para enviar mensaje KANBAN_READY');
            }
            
            return publicApi;
        })();

            // --- Inicialización ---
            // Función para inicializar el Kanban con un ID de OVC específico
            function initializeKanban(ovcId, ovcTitle) {
                console.log('Inicializando Kanban con OVC ID:', ovcId, 'Título:', ovcTitle);
                
                // Validar que se proporcione un ID de OVC
                if (!ovcId) {
                    console.warn('No se proporcionó un ID de OVC válido. Se requiere un ID para cargar el tablero Kanban.');
                    // No mostrar mensaje de error al usuario
                    return;
                }
                
                try {
                    // Establecer el estado de inicialización
                    window.kanbanInitialized = false;
                    
                    // Actualizar el título de la página
                    document.title = `Kanban - ${ovcTitle || 'Tablero sin título'}`;
                    
                    // Inicializar el tablero Kanban con el ID y título del OVC
                    console.log('Llamando a KanbanApp.init con:', { ovcId, ovcTitle });
                    KanbanApp.init(ovcId, ovcTitle);
                    
                    // Marcar como inicializado
                    window.kanbanInitialized = true;
                    
                    // Notificar a la ventana principal que el Kanban se inicializó correctamente
                    if (window.parent) {
                        window.parent.postMessage({ 
                            type: 'KANBAN_INITIALIZED',
                            ovcId: ovcId,
                            ovcTitle: ovcTitle
                        }, '*');
                    }
                    
                    // Verificar si el tablero se inicializó correctamente después de un breve retraso
                    setTimeout(() => {
                        if (!window.kanbanInitialized) {
                            console.error('Error: El tablero Kanban no se inicializó correctamente');
                            // Solo registrar en consola, no mostrar al usuario
                            console.warn('El tablero Kanban está tardando más de lo esperado en cargar.');
                            
                            // No notificar a la ventana principal sobre el error
                        }
                    }, 2000); // Esperar 2 segundos antes de verificar
                } catch (error) {
                    console.error('Error al inicializar el tablero Kanban:', error);
                    
                    // Solo registrar en consola, no mostrar al usuario
                    console.error('Error al inicializar el tablero Kanban:', error);
                    
                    // No notificar a la ventana principal sobre el error
                }
            }

        // Manejar mensajes de la ventana principal
        window.addEventListener('message', function(event) {
            console.log('Mensaje recibido en kanban.html:', event.data);
            
            // Verificar el origen del mensaje para mayor seguridad (opcional)
            // if (event.origin !== window.location.origin) {
            //     console.warn('Mensaje de origen no confiable:', event.origin);
            //     return;
            // }
            
            if (!event.data || !event.data.type) {
                console.log('Mensaje recibido sin tipo, ignorando...');
                return;
            }
            
            switch (event.data.type) {
                case 'INIT_KANBAN':
                    console.log('Inicializando Kanban con datos:', event.data);
                    
                    // Notificar que el Kanban está listo
                    if (window.parent) {
                        window.parent.postMessage({ 
                            type: 'KANBAN_READY'
                        }, '*');
                    }
                    
                    // Verificar si KanbanApp está disponible
                    if (typeof window.KanbanApp === 'undefined') {
                        console.error('Error: KanbanApp no está disponible');
                        return;
                    }
                    
                    // Cargar el tablero Kanban específico para este OVC
                    const ovcId = event.data.ovcId;
                    const ovcTitle = event.data.ovcTitle || 'Sin título';
                    
                    // Verificar si el tablero existe en el almacenamiento
                    const kanbanBoard = window.KanbanStorage ? window.KanbanStorage.getBoard(ovcId) : null;
                    
                    if (kanbanBoard) {
                        console.log('Tablero Kanban cargado desde el almacenamiento:', kanbanBoard);
                    } else {
                        console.log('No se encontró un tablero existente para este OVC, se creará uno nuevo');
                    }
                    
                    // Esperar a que el DOM esté listo
                    if (document.readyState === 'loading') {
                        console.log('DOM aún no está listo, esperando...');
                        document.addEventListener('DOMContentLoaded', () => {
                            console.log('DOM cargado, inicializando Kanban...');
                            initializeKanban(ovcId, ovcTitle);
                        });
                    } else {
                        console.log('DOM ya está listo, inicializando Kanban...');
                        initializeKanban(ovcId, ovcTitle);
                    }
                    break;
                    
                default:
                    console.log('Tipo de mensaje no manejado:', event.data.type);
            }
        });

        // Inicializar cuando se carga la página, pero también permitir inicialización externa
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DEBUG: kanban.html DOMContentLoaded event fired');
            
            // Notificar a la ventana principal que el DOM está cargado
            if (window.parent) {
                console.log('Enviando mensaje KANBAN_READY a la ventana principal desde DOMContentLoaded');
                window.parent.postMessage({ type: 'KANBAN_READY' }, '*');
            }
            
            // Notificar a la ventana padre que estamos listos para recibir la inicialización
            if (window.self !== window.top) {
                console.log('DEBUG: kanban.html cargado en iframe, notificando a la ventana padre');
                try {
                    window.parent.postMessage({ type: 'KANBAN_READY' }, '*');
                    console.log('DEBUG: Mensaje KANBAN_READY enviado a la ventana padre');
                } catch (e) {
                    console.error('ERROR: No se pudo enviar mensaje a la ventana padre:', e);
                }
            } else {
                console.log('DEBUG: Inicializando KanbanApp directamente (carga independiente)');
                // Si se carga directamente, inicializar sin ID de OVC
                initializeKanban();
            }
        });
        
        // También notificar cuando la ventana esté completamente cargada como respaldo
        window.addEventListener('load', function() {
            if (window.self !== window.top) {
                console.log('DEBUG: kanban.html completamente cargado, notificando a la ventana padre');
                try {
                    window.parent.postMessage({ type: 'KANBAN_READY' }, '*');
                    console.log('DEBUG: Mensaje KANBAN_READY enviado a la ventana padre (evento load)');
                } catch (e) {
                    console.error('ERROR: No se pudo enviar mensaje a la ventana padre (evento load):', e);
                }
            }
        });

    </script>

</body>

</html>